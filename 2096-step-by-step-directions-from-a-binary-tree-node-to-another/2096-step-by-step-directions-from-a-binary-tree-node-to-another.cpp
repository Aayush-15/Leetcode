
// Generated By Leetcode2IDE
#include <bits/stdc++.h>
using namespace std;
#define pb              push_back
#define mp              make_pair
#define pii             pair<int,int>
#define F               first
#define S               second
#define pbmax           priority_queue<int>//max heap
#define pbmin           priority_queue<int, vector<int>, greater<int>>//min heap priority_queue
#define lpi(i,a,b)      for(int i=a;i<b;i++)
#define lpd(i,a,b)      for(int i=b;i>=a;i--)
/****************************************************************************************/
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x <<" :"; _print(x);cerr<<'\n';
#else
#define debug(x)
#endif
void _print(int a) {cerr << a << " ";}
void _print(long long  a) {cerr << a << " ";}
void _print(char a) {cerr << a << " ";}
void _print(double a) {cerr << a << " ";}
void _print(float a) {cerr << a << " ";}
void _print(string a) { cerr << a << " ";}
template<class T> void _print(vector<T>v) {
	cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";
}
template<class T> void _print(set<T>s)
{
	cerr << "[ "; for (T i : s) {_print(i); cerr << " ";} cerr << "]";
}
template<class T> void _print(multiset<T>s)
{
	cerr << "[ "; for (T i : s) {_print(i); cerr << " ";} cerr << "]";
}
template <class T, class V> void _print(pair <T, V> pair_p) {
	cerr << "{"; _print(pair_p.first); cerr << ","; _print(pair_p.second); cerr << "}";
}
template <class T, class V> void _print(map <T, V> mp) {
	cerr << "[ "; for (auto i : mp) {_print(i); cerr << " ";} cerr << "]";
}
// /****************************************************************************************/
// struct TreeNode {
// 	int val;
// 	TreeNode *left;
// 	TreeNode *right;
// 	TreeNode()
// 	{
// 		val = 0;
// 		left = NULL;
// 		right = NULL;
// 	}
// 	TreeNode(int value)
// 	{
// 		val = value;
// 		left = NULL;
// 		right = NULL;
// 	}
// 	TreeNode(int value, TreeNode* l, TreeNode* r)
// 	{
// 		val = value;
// 		left = l;
// 		right = r;
// 	}

// };

class Solution {
public:
	bool generate_path(TreeNode* root, int desired_node, string &path)
	{
		if (root == NULL)
		{
			return false;
		}
		if (root->val == desired_node)
		{
			return true;
		}

		if (generate_path(root->left, desired_node, path))
		{
			path.push_back('L');
		}
		else if (generate_path(root->right, desired_node, path))
		{
			path.push_back('R');
		}
		return !path.empty();
	}
	string getDirections(TreeNode* root, int startValue, int destValue)
	{
		string res = "", root_to_start = "", root_to_end = "";
		generate_path(root, startValue, root_to_start);
		generate_path(root, destValue, root_to_end);
		// I have Path from start node to Root node->str(root_to_start)
		// I have Path from end Node to Root Node->str(root_to_end)
		//Pop Back the Common Suffix from Both The String(Which Is Path from Lca Node to Root Node)
		while (root_to_start.size() > 0 and root_to_end.size() > 0 and root_to_end.back() == root_to_start.back())
		{
			root_to_end.pop_back();
			root_to_start.pop_back();
		}
		//Since Lca is Ancestor of Start And End Node
		//Path from start to LCA node->Replace every step with 'U'->because move in upward direction every time
		for (auto &x : root_to_start)
		{
			x = 'U';
		}
		//Reverse the string which stores path from root to destination
		reverse(root_to_end.begin(), root_to_end.end());
		res = root_to_start + root_to_end;

		return res;
	}
};

// int main() {
// #ifndef ONLINE_JUDGE
// 	freopen("Error.txt", "w", stderr);
// #endif
// 	TreeNode* root = new TreeNode(8);
// 	root->left = new TreeNode(5);
// 	root->left->left = new TreeNode(1);
// 	root->left->right = new TreeNode(2);
// 	root->left->left->left = new TreeNode(3);
// 	root->left->left->right = new TreeNode(7);
// 	root->left->right->left = new TreeNode(6);
// 	root->left->right->right = new TreeNode(4);
// 	Solution S;
// 	int start, end;
// 	cin >> start >> end;
// 	string res = S.getDirections(root, start, end);
// 	cout << res << endl;
// 	return 0;
// }
